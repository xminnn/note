<!DOCTYPE html>
<html lang="zh" οndragstart="return false;">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>日志和监控系统设计</title>
    <link rel="stylesheet" href="../index.css" cache="force">
</head>

<body οndragstart="return false;">
    <div style="position: fixed; left: 0; top: 0; width: 100%; height: 100%; padding: 0;">
        <div class="left-container">
            <div class="header-container">
                <a href="https://github.com/xminnn"><img src="../icon.jpg" cache="force"></a>
            </div>
            <div id="dir-container">
                <div class="node-dir">
<div class="node-dir-name">c++</div>
<div class="node-children">
<div class="node-item">
<div id="article-7" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./7.html">c++基础总结</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040862" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040862.html">c++右值引用</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040863" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040863.html">c++模板元编程</a>
</div>
</div>
<div class="node-item">
<div id="article-8" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./8.html">c++模板的偏特化与全特化</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040864" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040864.html">c++虚表的内存结构</a>
</div>
</div>
<div class="node-item">
<div id="article-1745769480197" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745769480197.html">core保证日志写入</a>
</div>
</div>
<div class="node-item">
<div id="article-5" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./5.html">fopen</a>
</div>
</div>
<div class="node-item">
<div id="article-6" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./6.html">icmp实现ping</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078880027" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078880027.html">Makefile</a>
</div>
</div>
<div class="node-item">
<div id="article-9" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./9.html">mmap</a>
</div>
</div>
<div class="node-item">
<div id="article-1745082315831" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745082315831.html">socket配置</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040871" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040871.html">代码静态检测工具</a>
</div>
</div>
<div class="node-item">
<div id="article-1" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1.html">共享内存</a>
</div>
</div>
<div class="node-item">
<div id="article-3" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./3.html">开源游戏引擎以及工具</a>
</div>
</div>
<div class="node-item">
<div id="article-2" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./2.html">开源项目</a>
</div>
</div>
<div class="node-item">
<div id="article-4" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./4.html">性能分析</a>
</div>
</div>
</div>
</div>
<div class="node-dir">
<div class="node-dir-name">游戏后端</div>
<div class="node-children">
<div class="node-item">
<div id="article-1745504985606" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745504985606.html">服务器消息架构</a>
</div>
</div>
<div class="node-item">
<div id="article-1745504985608" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745504985608.html">道具系统</a>
</div>
</div>
<div class="node-item">
<div id="article-1745504985607" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745504985607.html">条件系统</a>
</div>
</div>
<div class="node-item">
<div id="article-1745082315832" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745082315832.html">好文推荐</a>
</div>
</div>
<div class="node-item">
<div id="article-1745765918114" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745765918114.html">导表设计</a>
</div>
</div>
<div class="node-item">
<div id="article-1745937479784" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745937479784.html">排名系统</a>
</div>
</div>
<div class="node-item">
<div id="article-1745769496998" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745769496998.html">日志和监控系统设计</a>
</div>
</div>
</div>
</div>
<div class="node-dir">
<div class="node-dir-name">服务</div>
<div class="node-children">
<div class="node-item">
<div id="article-27" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./27.html">elasticsearch</a>
</div>
</div>
<div class="node-item">
<div id="article-26" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./26.html">kafka</a>
</div>
</div>
<div class="node-item">
<div id="article-25" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./25.html">mongo</a>
</div>
</div>
<div class="node-item">
<div id="article-24" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./24.html">mysql</a>
</div>
</div>
<div class="node-item">
<div id="article-23" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./23.html">redis</a>
</div>
</div>
</div>
</div>
<div class="node-dir">
<div class="node-dir-name">算法</div>
<div class="node-children">
<div class="node-item">
<div id="article-39" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./39.html">huffman压缩算法</a>
</div>
</div>
<div class="node-item">
<div id="article-40" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./40.html">lz77压缩算法</a>
</div>
</div>
<div class="node-item">
<div id="article-41" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./41.html">md5算法</a>
</div>
</div>
<div class="node-item">
<div id="article-42" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./42.html">二叉树</a>
</div>
</div>
<div class="node-item">
<div id="article-44" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./44.html">其他常见算法题</a>
</div>
</div>
<div class="node-item">
<div id="article-36" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./36.html">加密算法</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040877" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040877.html">动态规划</a>
</div>
</div>
<div class="node-item">
<div id="article-37" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./37.html">寻路算法</a>
</div>
</div>
<div class="node-item">
<div id="article-31" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./31.html">排序算法</a>
</div>
</div>
<div class="node-item">
<div id="article-33" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./33.html">时间轮</a>
</div>
</div>
<div class="node-item">
<div id="article-30" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./30.html">查找算法</a>
</div>
</div>
<div class="node-item">
<div id="article-43" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./43.html">栈和队列</a>
</div>
</div>
<div class="node-item">
<div id="article-38" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./38.html">正太分布随机数算法</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040878" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040878.html">游戏开发中的噪声算法</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040879" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040879.html">算法思想</a>
</div>
</div>
<div class="node-item">
<div id="article-34" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./34.html">缓存淘汰算法</a>
</div>
</div>
<div class="node-item">
<div id="article-35" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./35.html">调度算法</a>
</div>
</div>
<div class="node-item">
<div id="article-32" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./32.html">跳表</a>
</div>
</div>
<div class="node-item">
<div id="article-45" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./45.html">链表</a>
</div>
</div>
</div>
</div>
<div class="node-dir">
<div class="node-dir-name">linux</div>
<div class="node-children">
<div class="node-item">
<div id="article-15" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./15.html">dns修改</a>
</div>
</div>
<div class="node-item">
<div id="article-1745769480199" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745769480199.html">linux测试磁盘读写速度</a>
</div>
</div>
<div class="node-item">
<div id="article-1745769480200" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745769480200.html">linux添加swap分区</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040872" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040872.html">proot</a>
</div>
</div>
<div class="node-item">
<div id="article-16" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./16.html">qemu</a>
</div>
</div>
<div class="node-item">
<div id="article-17" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./17.html">ssh穿透</a>
</div>
</div>
<div class="node-item">
<div id="article-18" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./18.html">surfacebook2安装archlinux记录</a>
</div>
</div>
<div class="node-item">
<div id="article-19" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./19.html">systemctl守护自定义程序</a>
</div>
</div>
<div class="node-item">
<div id="article-1745505189602" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745505189602.html">tcp抓包</a>
</div>
</div>
<div class="node-item">
<div id="article-13" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./13.html">代理</a>
</div>
</div>
<div class="node-item">
<div id="article-12" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./12.html">常用命令</a>
</div>
</div>
<div class="node-item">
<div id="article-11" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./11.html">常见问题</a>
</div>
</div>
<div class="node-item">
<div id="article-14" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./14.html">用户与权限</a>
</div>
</div>
<div class="node-item">
<div id="article-22" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./22.html">设置core文件</a>
</div>
</div>
<div class="node-item">
<div id="article-20" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./20.html">配置网络</a>
</div>
</div>
<div class="node-item">
<div id="article-21" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./21.html">镜像源</a>
</div>
</div>
</div>
</div>
<div class="node-dir">
<div class="node-dir-name">工具</div>
<div class="node-children">
<div class="node-item">
<div id="article-49" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./49.html">ai对话</a>
</div>
</div>
<div class="node-item">
<div id="article-50" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./50.html">ai绘画</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040874" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040874.html">blender</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040875" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040875.html">docker</a>
</div>
</div>
<div class="node-item">
<div id="article-47" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./47.html">git</a>
</div>
</div>
<div class="node-item">
<div id="article-48" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./48.html">svn</a>
</div>
</div>
<div class="node-item">
<div id="article-53" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./53.html">vim</a>
</div>
</div>
<div class="node-item">
<div id="article-46" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./46.html">vscode</a>
</div>
</div>
<div class="node-item">
<div id="article-52" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./52.html">winfsp</a>
</div>
</div>
<div class="node-item">
<div id="article-1745078040876" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040876.html">网址大全</a>
</div>
</div>
<div class="node-item">
<div id="article-51" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./51.html">软媒工具组件精选</a>
</div>
</div>
</div>
</div>
<div class="node-dir">
<div class="node-dir-name">其他</div>
<div class="node-children">
<div class="node-item">
<div id="article-1745078040873" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745078040873.html">Android开发环境快速搭建</a>
</div>
</div>
<div class="node-item">
<div id="article-1745506516212" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./1745506516212.html">opengl积雪效果</a>
</div>
</div>
<div class="node-item">
<div id="article-55" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./55.html">python简单日志工具</a>
</div>
</div>
<div class="node-item">
<div id="article-58" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./58.html">windows相关</a>
</div>
</div>
<div class="node-item">
<div id="article-56" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./56.html">开源协议</a>
</div>
</div>
<div class="node-item">
<div id="article-57" class="node-one">
<div class="tab_1"></div>
<a clas="node-name" href="./57.html">终端输出特殊代码</a>
</div>
</div>
</div>
</div>

            </div>
        </div>
        <div class="right-container">
            <div id="md-container">
                <div class="title"> 日志和监控系统设计 </div>
                <div class="info">
                    <div class="create_time">创建:2025-04-27 23:57</div>
                    <div class="update_time">更新:2025-04-27 23:57</div>
                </div>
                <div class="line"></div>

                <div id="md-container-content" style="position: relative;"><h3 id="">日志收集、查询和监控</h3>
<p>常见的日志收集系统架构是<code>ELK</code>: <code>Logstash</code>+<code>Kafka</code>+<code>Elasticsearch</code>。</p>
<p><img src="../res/日志和监控系统设计.png" alt="alt text" /></p>
<p>其中kibana可以实现各种数据表格的展示，elasticsearch的日志全文查找，以及监控告警</p>
<p>另外一个简单的替代方案是：OpenObserve</p>
<p><img src="../res/日志和监控系统设计-1.png" alt="alt text" /></p>
<p><img src="../res/日志和监控系统设计-2.png" alt="alt text" /></p>
<h4 id="-1"># 我的方案</h4>
<p>开源方案虽然强大，按时一般都需要一个运维团队专门做支持。而且游戏开发中存在多个环境, 所以维护成本巨大(光配置都需要巨大的维护精力)。因为本人同样熟悉web前后端开发，所以选择直接使用代码实现自己想要的效果，同时多环境部署无压力，直接启动服务即可，无配置即可完成多环境一致效果。</p>
<p>架构如图：</p>
<p><img src="../res/日志和监控系统设计-3.png" alt="alt text" /></p>
<p>效果如图:</p>
<p><img src="../res/日志和监控系统设计-4.png" alt="alt text" /><br />
<img src="../res/日志和监控系统设计-5.png" alt="alt text" /></p>
<h3 id="-2">程序中的日志输出</h3>
<p>在游戏服务器中，主要关注的日志包括：错误日志，告警日志(如请求处理缓慢，负载过高，错误数过大等等)，用户行为日志(埋点)。同时需要对日志进行染色，能够查询并直观查看请求在多个服务之间的流转。</p>
<p>其中对于埋点，有些设计中是直接通过网络发送出去。</p>
<p>这里实现一个简单c版本的多线程日志库，能够满足游戏开发的基础需求。做到了以下几点：</p>
<ol>
<li>日志染色，全局的gseq, 方便日志追踪</li>
<li>自定义tag, 方便日志收集器区分投递，例如告警日志需要进行告警投递</li>
<li>自动识别类型，使用<code>?</code>替代<code>%d %u %lu ...</code> 等，方便编写</li>
<li>支持积压限制，避免误写死循环代码，导致日志框架内存暴涨而崩溃</li>
<li>足够的性能：<ul>
<li>加防死循环，队列限制最多积压5000条。 100w输出需要4.2s, 大概每条 4us. 每秒25w</li>
<li>不加防死循环，队列积压不限制。100w输出需要319ms. 大概每条 0.3us. 每秒300w. 如果磁盘速度更不上的话，可能积压导致会爆内存</li></ul></li>
<li>支持日志滚动</li>
<li>动态链接模式下，支持错误栈输出。方便定位错误日志触发的函数调用路径</li>
</ol>
<pre><code class="c language-c">#pragma once

struct string_view {    // 为了一些没有以\0结尾的字符串使用
    const char* buff;
    int buff_size;
};

#define _get_type(var) _Generic((var), \
    int: 1,                            \
    short: 1,                          \
    double: 2,                         \
    float: 2,                          \
    char*: 3,                          \
    char: 5,                           \
    long long: 6,                      \
    unsigned char: 7,                  \
    unsigned short: 8,                 \
    unsigned int: 8,                   \
    unsigned long long: 9,             \
    unsigned long: 9,                  \
    struct string_view: 10,            \
    const char*: 3)

#define _append_seq_1(a) _get_type(a), a
#define _append_seq_2(a, args...) _get_type(a), a, _append_seq_1(args)
#define _append_seq_3(a, args...) _get_type(a), a, _append_seq_2(args)
#define _append_seq_4(a, args...) _get_type(a), a, _append_seq_3(args)
#define _append_seq_5(a, args...) _get_type(a), a, _append_seq_4(args)
#define _append_seq_6(a, args...) _get_type(a), a, _append_seq_5(args)
#define _append_seq_7(a, args...) _get_type(a), a, _append_seq_6(args)
#define _append_seq_8(a, args...) _get_type(a), a, _append_seq_7(args)
#define _append_seq_9(a, args...) _get_type(a), a, _append_seq_8(args)
#define _append_seq_10(a, args...) _get_type(a), a, _append_seq_9(args)
#define _append_seq_11(a, args...) _get_type(a), a, _append_seq_10(args)
#define _append_seq_12(a, args...) _get_type(a), a, _append_seq_11(args)
#define _append_seq_13(a, args...) _get_type(a), a, _append_seq_12(args)
#define _append_seq_14(a, args...) _get_type(a), a, _append_seq_13(args)
#define _append_seq_15(a, args...) _get_type(a), a, _append_seq_14(args)
#define _append_seq_16(a, args...) _get_type(a), a, _append_seq_15(args)
#define _append_seq_n(n, args...) _append_seq_##n(args)
#define _get_types(n, args...) _append_seq_n(n, args)
#define _arg_n(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, n, ...) n
#define _count_args(args...) _arg_n(args, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)

static inline int snformat_ignore_(const char* fmt, ...) { return 1; }    // ignore unused value error
int snformat_(char* dist, int size, const char* fmt, ...);
#define snformat(dist, size, fmt, args...) snformat_(dist, size, fmt, _get_types(_count_args(args), args))

int log_thread_init();
int log_append(int level, int stack_color, const char* text, int text_size);
void log_safe_exit();
void log_print_level(int level);

#define k_log_level_debug 1
#define k_log_level_info 2
#define k_log_level_warn 3
#define k_log_level_error 4
#define k_log_level_user 5

extern char log_buff_[2048];
extern unsigned long long log_gseq_;
#define log_(level, tag, stack_color, color, fmt, args...) log_append(level, stack_color, log_buff_, snformat(log_buff_, sizeof(log_buff_), "[gseq:?][" tag "][?:?]" color fmt "\033[0m", log_gseq_, __FILE__, __LINE__, ##args))
#define logd(fmt, args...) log_(k_log_level_debug, "debug", 0, "\033[0m", " " fmt, ##args)
#define logi(fmt, args...) log_(k_log_level_info, "info", 0, "\033[32m", " " fmt, ##args)
#define logw(fmt, args...) log_(k_log_level_warn, "warn", 0, "\033[33m", " " fmt, ##args)
#define loge(fmt, args...) log_(k_log_level_error, "error", 31, "\033[31m", " " fmt, ##args)
#define logx(tag, fmt, args...) snformat_ignore_(fmt, ##args)

#ifdef __release__
#undef logd
#undef loge
#undef logx
#define logx(tag, fmt, args...) log_(k_log_level_user, tag, 0, "\033[35m", " " fmt, ##args)
#define logd(fmt, args...) snformat_ignore_(fmt, ##args)
#define loge(fmt, args...) log_(k_log_level_error, "error", 0, "\033[31m", " " fmt, ##args)

// #undef log_
// #define log_(level, tag, stack_color, color, fmt, args...) snformat_ignore_(fmt, ##args)
#endif
</code></pre>
<p>-&gt; 日志库实现</p>
<pre><code class="c language-c">#include "log.h"
#define _GNU_SOURCE
#include &lt;memory.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;unistd.h&gt;

static int format_(char* out_buff, int size, const char* fmt, va_list argp) {
    int out_size = 0;
    int type = va_arg(argp, int);
    for (const char* p = fmt; *p != '\0'; p++) {
        if (*p != '?') {
            out_buff[out_size++] = *p;
            continue;
        }
        if (*(p + 1) == '!') {
            out_buff[out_size++] = '?';
            p++;
            continue;
        }
        switch (type) {
            case 1: {
                int arg = va_arg(argp, int);
                int n = snprintf(out_buff + out_size, size - out_size, "%d", arg);
                out_size += n;
                type = va_arg(argp, int);
                break;
            }
            case 2: {
                double arg = va_arg(argp, double);
                int n = snprintf(out_buff + out_size, size - out_size, "%g", arg);
                out_size += n;
                type = va_arg(argp, int);
                if (out_size &gt; size) {
                    return 0;
                }
                break;
            }
            case 3: {
                char* arg = va_arg(argp, char*);
                int n = snprintf(out_buff + out_size, size - out_size, "%s", arg);
                out_size += n;
                type = va_arg(argp, int);
                break;
            }
            case 4: {
                int arg = va_arg(argp, int);
                if (arg == 1) {
                    int n = snprintf(out_buff + out_size, size - out_size, "true");
                    out_size += n;
                } else if (arg == 0) {
                    int n = snprintf(out_buff + out_size, size - out_size, "false");
                    out_size += n;
                } else {
                    int n = snprintf(out_buff + out_size, size - out_size, "%c", arg);
                    out_size += n;
                }
                type = va_arg(argp, int);
                break;
            }
            case 5: {
                int arg = va_arg(argp, int);
                int n = snprintf(out_buff + out_size, size - out_size, "%c", arg);
                out_size += n;
                type = va_arg(argp, int);
                break;
            }
            case 6: {
                long long arg = va_arg(argp, long long);
                int n = snprintf(out_buff + out_size, size - out_size, "%lld", arg);
                out_size += n;
                type = va_arg(argp, int);
                break;
            }
            case 7: {
                unsigned char arg = va_arg(argp, unsigned int);
                int n = snprintf(out_buff + out_size, size - out_size, "%u", arg);
                out_size += n;
                type = va_arg(argp, int);
                break;
            }
            case 8: {
                unsigned int arg = va_arg(argp, unsigned int);
                int n = snprintf(out_buff + out_size, size - out_size, "%u", arg);
                out_size += n;
                type = va_arg(argp, int);
                break;
            }
            case 9: {
                unsigned long long arg = va_arg(argp, unsigned long long);
                int n = snprintf(out_buff + out_size, size - out_size, "%llu", arg);
                out_size += n;
                type = va_arg(argp, int);
                break;
            }
            case 10: {
                struct string_view arg = va_arg(argp, struct string_view);
                int n = arg.buff_size &gt; size - out_size ? size - out_size : arg.buff_size;
                memcpy(out_buff + out_size, arg.buff, n);
                out_size += n;
                type = va_arg(argp, int);
                break;
            }
            default: {
                va_arg(argp, void*);
                type = va_arg(argp, int);
                break;
            }
        }
        if (out_size &gt;= size) {
            break;
        }
    }
    out_buff[out_size] = 0;
    return out_size;
}

int snformat_(char* dist, int size, const char* fmt, ...) {
    va_list argp;
    va_start(argp, fmt);
    int out_size = format_(dist, size, fmt, argp);
    va_end(argp);
    return out_size;
}

char log_buff_[2048];
char log_stack_buff_[1024];
unsigned long long log_gseq_;

struct log_element {
    struct timeval tv;
    struct log_element* next;
    char* text;
};

struct log_element_list {
    struct log_element* head;
    struct log_element* tail;
    int count;
};

struct log_thread_ {
    pthread_cond_t cond;
    pthread_mutex_t mutex;
    pthread_t thread;
    FILE* file;
    char file_name[1024];
    long long file_time;
    long long file_size;
    int thread_inited;
    int exited;
    int level;

    int append;
    int output;
    struct log_element_list list[2];
};

static struct log_thread_ self = {0};

void log_print_level(int level) {
    self.level = level;
}

static void exit_close_() {
    if (self.exited) {
        printf("log thread already exiting...\n");
        return;
    }
    if (self.thread_inited) {
        self.exited = 1;
        printf("log thread exiting...\n");
        pthread_mutex_lock(&amp;self.mutex);
        pthread_cond_signal(&amp;self.cond);
        pthread_mutex_unlock(&amp;self.mutex);
        pthread_join(self.thread, NULL);
        if (self.file) {
            fclose(self.file);
        }
        pthread_cond_destroy(&amp;self.cond);
        pthread_mutex_destroy(&amp;self.mutex);
        printf("log thread exited\n");
    }
}

void log_safe_exit() {
    exit_close_();
}

static int create_dir_(const char* path) {
    struct stat st = {0};
    if (stat(path, &amp;st) == -1) {
        if (mkdir(path, 0700) == -1) {
            return 0;
        }
    }
    return 1;
}

static void log_print_(struct log_element* element) {
    time_t tick = (time_t)(element-&gt;tv.tv_sec);
    char time_str[100];

    if (self.file_size &gt; 1024 * 1024 * 500) {
        if (element-&gt;tv.tv_sec / 86400 == self.file_time / 86400) {
            int n = strftime(time_str, 50, "%Y%m%d.%H%M%S", localtime(&amp;tick));
            time_str[n] = 0;
            char temp[1024];
            snformat(temp, sizeof(temp), "./log/?.log", time_str);
            struct stat st;
            if (stat(temp, &amp;st) == -1) {
                rename(self.file_name, temp);
                self.file = fopen(self.file_name, "a+");
            }
            self.file_size = 0;
        }
    }
    if (!self.file || element-&gt;tv.tv_sec / 86400 &gt; self.file_time / 86400) {
        if (self.file) {
            fclose(self.file);
        }
        create_dir_("./log");
        int n = strftime(time_str, 50, "%Y%m%d", localtime(&amp;tick));
        time_str[n] = 0;
        snformat(self.file_name, sizeof(self.file_name), "./log/?.log", time_str);
        self.file_time = element-&gt;tv.tv_sec;
        self.file = fopen(self.file_name, "a+");
        struct stat st;
        if (stat(self.file_name, &amp;st) != -1) {
            self.file_size = st.st_size;
        }
    }

    int n = strftime(time_str, 100, "%Y-%m-%d %H:%M:%S", localtime(&amp;tick));
    time_str[n] = 0;

    static char long_text[4096];
    int len = snprintf(long_text, 4095, "[%s:%03d.%03d]%s", time_str, (int)(element-&gt;tv.tv_usec / 1000), (int)(element-&gt;tv.tv_usec % 1000), element-&gt;text);
    long_text[len] = 0;
    self.file_size += len + 1;

    fwrite(long_text, 1, len, self.file);
    fwrite("\n", 1, 1, self.file);
    fflush(self.file);

#ifndef __log_no_printf__
    printf("%s\n", long_text);
#endif

    free(element);
}

static void* log_thread_(void* arg) {
    printf("log thread inited\n");
    while (!self.exited || self.list[0].count &gt; 0 || self.list[1].count &gt; 0) {
        pthread_mutex_lock(&amp;self.mutex);
        while (self.list[self.append].count &lt;= 0 &amp;&amp; self.exited != 1) {
            pthread_cond_wait(&amp;self.cond, &amp;self.mutex);
        }
        int tmp = self.append;
        self.append = self.output;
        self.output = tmp;
        pthread_mutex_unlock(&amp;self.mutex);

        struct log_element_list* it = &amp;self.list[self.output];
        struct log_element* ele = it-&gt;head;
        while (ele) {
            struct log_element* next = ele-&gt;next;
            log_print_(ele);
            ele = next;
        }
        it-&gt;count = 0;
        it-&gt;head = 0;
        it-&gt;tail = 0;
    }
    return 0;
}

int log_thread_init() {
    if (self.thread_inited) {
        printf("log thread had inited\n");
        return 0;
    }
    memset(&amp;self, 0, sizeof(self));
    int result = pthread_mutex_init(&amp;self.mutex, NULL);
    if (result != 0) {
        printf("int thread mutex failed: %d\n", result);
        return 0;
    }
    result = pthread_cond_init(&amp;self.cond, NULL);
    if (result != 0) {
        printf("int thread mutex failed: %d\n", result);
        return 0;
    }
    result = pthread_create(&amp;self.thread, 0, log_thread_, 0);
    if (result != 0) {
        printf("create log thread failed: %d\n", result);
        return 0;
    }
    pthread_setname_np(self.thread, "log_thread");
    atexit(exit_close_);
    self.thread_inited = 1;
    self.output = 1;
    self.append = 0;
    return 1;
}

#ifdef __GNUC__
#include &lt;execinfo.h&gt;
#endif

int log_append(int level, int stack_color, const char* text, int text_size) {
    if (level &lt; self.level) {
        return 0;
    }
#ifdef __GNUC__
#ifndef __release__
    if (stack_color != 0) {
        // to get a visualized stack list output when use loge, you need to link with -rdynamic and no -O3.
        static char log_stack_buff[4096];
        strncpy(log_stack_buff, text, sizeof(log_stack_buff) - 1);
        void* array[100];
        size_t size = backtrace(array, 100);
        char** strings = backtrace_symbols(array, size);
        char* stack_info = log_stack_buff;
        int k = text_size;
        k += snprintf(stack_info + k, sizeof(log_stack_buff) - k, "\033[%dm", stack_color);
        for (size_t i = 1; i &lt; size - 2; i++) {
            int slen = strlen(strings[i]);
            strncpy(stack_info + k, "\n    ", sizeof(log_stack_buff) - k);
            k += 5;
            strncpy(stack_info + k, strings[i], sizeof(log_stack_buff) - k);
            k += slen;
        }
        strncpy(stack_info + k, "\033[0m", sizeof(log_stack_buff) - k);
        k += 5;
        log_stack_buff[k] = 0;
        text_size = k;
        text = log_stack_buff;
    }
#endif
#endif
    while (self.list[self.append].count &gt; 10000) {
        usleep(1000);    // 限制内存增长速度(框架的输出速度大概2000/ms, 高性能机器应该调整更大), 避免死循环刷日志，当检测到日志慢的时候，则强制线程等待
    }
    struct log_element* element = (struct log_element*)malloc(sizeof(struct log_element) + text_size + 1);
    gettimeofday(&amp;element-&gt;tv, NULL);
    element-&gt;next = 0;
    element-&gt;text = ((char*)element) + sizeof(struct log_element);
    memcpy(element-&gt;text, text, text_size);
    element-&gt;text[text_size] = 0;
    if (self.thread_inited) {
        pthread_mutex_lock(&amp;self.mutex);
        struct log_element_list* it = &amp;self.list[self.append];
        if (it-&gt;count != 0) {
            it-&gt;tail-&gt;next = element;
            it-&gt;tail = element;
        } else {
            it-&gt;tail = element;
            it-&gt;head = element;
        }
        it-&gt;count++;
        pthread_cond_signal(&amp;self.cond);
        pthread_mutex_unlock(&amp;self.mutex);
    } else {
        static pthread_t single_thread = 0;
        if (single_thread == 0) {
            single_thread = pthread_self();
            printf("single thread log append\n");
        }
        if (single_thread != pthread_self()) {
            static int single_thread_warnig = 0;
            if (single_thread_warnig &lt; 1) {
                printf("In multi-threaded environment, please use log_thread_init to initialize the log module first.\n");
                single_thread_warnig++;
            }
            return 0;
        }
        log_print_(element);
    }
    return 1;
}
</code></pre>
<p>使用：</p>
<pre><code class="c language-c">void error_test(){
    loge("test");
}
int main(int argc, char const *argv[]) {
    log_thread_init();
    log_print_level(k_log_level_debug);
    logd("begin");
    logw("test");
    logi("test");
    error_test();
    logx("stat", "test");
    return 0;
}
</code></pre>
<p><img src="../res/日志和监控系统设计-6.png" alt="alt text" /></p>
<p>额外的，core掉保证输出完毕，需要拦截core型号，调用 <code>log_safe_exit</code> 函数确保输出完毕:</p>
<pre><code class="c language-c">#include &lt;signal.h&gt;
#include &lt;syslog.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;

void handle_core_signal(int sig, siginfo_t* info, void* context) {
    static int happened = 0;
    if (!happened) { // 避免递归core
        happened = 1;
        log_safe_exit(); // 确保下发完毕
    }

    // 恢复默认信号处理
    struct sigaction sa;
    sa.sa_handler = SIG_DFL;
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(sig, &amp;sa, 0);
    // 重新触发信号（生成核心文件）
    kill(getpid(), sig);
}

int main() {
    // 设置信号处理
    struct sigaction sa;
    sa.sa_sigaction = handle_core_signal;
    sigemptyset(&amp;sa.sa_mask);
    sa.sa_flags = SA_SIGINFO;
    sigaction(SIGSEGV, &amp;sa, 0);  // 段错误
    sigaction(SIGABRT, &amp;sa, 0);  // 中止信号
    sigaction(SIGFPE,  &amp;sa, 0);  // 浮点异常

    // 模拟触发段错误（解引用空指针）
    int* ptr = 0;
    *ptr = 42;  // 这里会触发SIGSEGV
    return 0;
}
</code></pre></div>
            </div>
        </div>
    </div>

    <script>
        let scrollTop = window.localStorage.getItem('scrollTop');
        let container = document.getElementById("dir-container");
        if (scrollTop) {
            container.scrollTop = scrollTop;
        } else {
            let id = window.location.pathname.substring(window.location.pathname.lastIndexOf('/') + 1);
            id = id.substring(0, id.length - 5);
            if (id != "index") {
                const autoScoll = function (element, root) {
                    element.scrollIntoView({
                        behavior: "smooth",
                        block: "nearest"
                    });
                };
                console.log(`articles-${id}`);
                autoScoll(document.getElementById(`article-${id}`), container);
            }
        }
        window.onbeforeunload = function () {
            window.localStorage.setItem('scrollTop', container.scrollTop);
        };
    </script>

    <link rel="stylesheet" href="../third/pace-theme-minimal.tmpl.css" cache="force">
    <link rel="stylesheet" href="../third/atom-one-dark.css" cache="force">
    <script data-pace-options='{ "ajax": false }' src="../third/pace.js" cache="force"></script>
    <script src="../third/highlight.pack.js" cache="force"></script>

    <script>
        let mdContainer = document.getElementById("md-container");
        hljs.initHighlightingOnLoad();
        for (const it of mdContainer.querySelectorAll("pre code")) {
            hljs.highlightBlock(it);
        }
        for (const pre of mdContainer.querySelectorAll("pre")) {
            let last = pre.previousElementSibling;
            if (last && last.tagName == "P" && (last.innerHTML.startsWith("+&gt; ") || last.innerHTML.startsWith("-&gt; "))) {
                let desc = document.createElement("div");
                desc.className = 'foldable';
                if (last.innerHTML.startsWith("-&gt; ")) {
                    desc.innerHTML = "▶ " + last.innerHTML.substring("-&gt; ".length);
                    pre.style.display = "none";
                } else {
                    desc.innerHTML = "▼ " + last.innerHTML.substring("+&gt; ".length);
                    pre.style.display = "";
                }
                pre.style.marginTop = "0";
                pre.style.marginBottom = "0";

                last.innerHTML = "";
                last.className += ' foldable-parent';
                last.addEventListener("click", () => {
                    if (pre.style.display == "none") {
                        desc.innerHTML = "▼ " + desc.innerHTML.substring("▶ ".length);
                        pre.style.display = "";
                    } else {
                        desc.innerHTML = "▶ " + desc.innerHTML.substring("▼ ".length);
                        pre.style.display = "none";
                    }
                });
                last.appendChild(desc);
                last.appendChild(pre);
            }
        }

        //点击查看原图
        for (const img of document.querySelectorAll("#md-container img")) {
            img.onclick = function () {
                console.log("click");
                let newDiv = document.createElement('div');
                newDiv.setAttribute("class", "img-view-bkg");

                let hitDiv = document.createElement('div');
                hitDiv.setAttribute("class", "img-view-hint");
                hitDiv.innerHTML = "双击图片或者点击空白处取消图片查看";

                let newImg = document.createElement('img');
                newImg.setAttribute("class", "img-view-img");
                newImg.src = this.src;

                let newSpan = document.createElement("div");
                newSpan.setAttribute("class", "img-view");
                newSpan.appendChild(newDiv);
                newSpan.appendChild(newImg);
                newSpan.appendChild(hitDiv);
                document.body.appendChild(newSpan);

                newImg.ondblclick = function () {
                    document.body.removeChild(newSpan);
                };

                newDiv.onclick = function () {
                    document.body.removeChild(newSpan);
                };
            };
        }

        MathJax = {
            tex: { inlineMath: [['$', '$'], ['\\(', '\\)']] },
            chtml: {
                displayAlign: 'left'
            }
        };
        let oldOnLoad = window.onload;
        window.onload = () => {
            let spt = document.createElement("script");
            spt.setAttribute("id", "MathJax-script");
            spt.setAttribute("async", true);
            spt.setAttribute("src", "../third/tex-chtml.js");
            document.body.append(spt);

            if (oldOnLoad) {
                oldOnLoad();
            }
        };
    </script>
</body>

</html>